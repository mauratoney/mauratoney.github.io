To start, download an Arch ISO and the respective PGP signature. On Windows, to verify the signature download Gpg4win and then use the command gpg --auto-key-locate clear,wkd -v --locate-external-key pierre@archlinux.org. This is just one option for an external key. With that done, the signature can be verified with the command gpg --verify <signature file name> <iso file name>. If the command indicates the two match, the iso should be safe to use. 

To actually install Arch, start by creating a new virtual machine. Provide the Arch ISO file and choose 'Other Linux 6.x kernel 64-bit' for the operating system as there is no specific listing for Arch and this is the general category the current Arch operating system falls under. The virtual machine was given one processor with 4 cores, eight gigabytes of RAM, and 24 gigabytes of storage. Upon creating the new virtual machine I realized Microsoft had stored the virtual machine in my OneDrive and so I deleted and recreated the virtual machine in a new location. 

The next step was to set up and configure the operating system. Initial decisions such as console keymap and keyboard layout were left as the default since it defaulted to the United States. I increased the fontsize to something more readable with setfont ter-v20n. Since my virtual machine was created on VMware Workstation, it was unable to boot into UEFI mode by default, so I added firmware="efi" to the "Arch.vmx" file. I did this with my virtual machine still on originally, so when I restarted the change was overwritten. The change needed to be made while the machine was off. To double check that the file had been properly modified I ran the command cat /sys/firmware/efi/fw_platform_size and it returned 64 indicating that it did in fact set it to boot into UEFI mode. I then pinged ping.archlinux.org to see that, at least at the moment, I had an internet connection. I then set my time zone using 'set-timezone America/Chicago'. Running 'timedatectl status' indicated the proper local time showing that my time zone was set correctly. The next step was to partition the disk. To  start I ran the command "fdisk /dev/sda" then typed g and hit enter to create a new empty GPT partition table. I then selected n to create a new partition, gave it the default partition number of 1, the default first sector, then typed +1G to make this first sector 1 gibibyte long. The other two sectors were made similarly, but given partition numbers of 2 and 3 and sizes of 4 gibibytes and 19 gibibytes respectively. Typing p printed the table to show all the partitions that were just created, and they seemed correct so I then saved(w) and quit(q). With the partitions created it is now time to give them their purpose. The command 'mkfs.ext4 /dev/sda3' uses the third partition that was just created to make an Ext4 file system. Then, 'mkswap /dev/sda2' initializes the partition intended for the swap space and 'mkfs.fat -F 32 /dev/sda1' formats the first partition for use as the EFI system partition. With the partitions formatted the files systems can be mounted. Use the commands 'mount /dev/sda3 /mnt', 'mount --mkdir /dev/sda1 /mnt/boot', and 'swapon /dev/sda2' to align partitions 1 and 3 with their intended purposes and to allow partition 2 to be used as the swap space.

With the file system created, essential packages can be installed. I ran the command 'pacstrap -K /mnt base linux linux-firmware vim man-db man-pages dhcpcd' to install many of the most essential functionalities for my purposes. Then I ran 'genfstab -U /mnt >> /mnt/etc/fstab' to get the file systems mounted on startup. Then I able to change root into the new system with 'arch-chroot /mnt'. I then created a link to set the time zone with 'ln -sf /usr/share/zoneinfo/America/Chicago /etc/localtime' and ran 'hwclock --systohc'. Next, I ran 'locale-gen' to generate the locales, and uncommented the 'en_US.UTF-8' in locale.conf. I created /etc/hostname and put in the hostname maura-arch and ran 'mkinitcpio -P' which was probably not necessary. Lastly I set the root password and installed grub with 'pacman -S grub' to be the system's bootloader and ran 'grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB' and 'grub-mkconfig -o /boot/grub/grub.cfg' to finish setting up the boot loader. At this point I was able to reboot into the Arch OS. 

Upon rebooting I no longer had internet connection. I had to run the command 'ip link set ens33 up' to get the link back up, then edited /etc/resolv.conf to put nameserver 1.1.1.1 and nameserver 8.8.8.8. I thought this would be a permanent solution but as soon as I had to restart my virtual machine again, I once again no longer had internet. I was, however, able to use this temporary connection to run 'pacman -S networkmanager' followed by 'systemctl enable NetworkManager.service' and this seems to be connecting me to the internet automatically on start up. With internet reestablished, I was able to install sudo and create a user account 'maura' for myself using 'useradd -m maura'. I set myself a password with 'passwd maura'. Then I added my account to the wheel group with 'usermod -aG wheel maura' and then editted the visudo file to uncomment the line that gives the users in the wheel group sudo permissions. Since the maura account is in the wheel group, it now has sudo permission. 

The next step was to install a desktop environment. I started by trying to install xorg but that did not work because the mirrors from which pacman downloads things were not as up to date as they could be. To remedy this I used 'sudo pacman -Sy reflector' to install the reflector then 'reflector --latest 10 --sort rate --save /etc/pacman.d/mirrorlist' to update the mirror file with the latest mirrors. Then I tried 'pacman -S xorg' again and it worked. I also installed 'plasma' and 'kde-applications' similarly choosing the default options for all. I was then able to reboot and had a desktop environment. 

The work from here on out was done in the Konsole. I created a codi user with 'sudo useradd -m codi' and added codi to the wheel group with 'sudo usermod -aG wheel codi'. My vm is having some difficulty syncing properly with the keyboard so setting the password for codi was unnecessarily difficult but was managed eventually. Adding codi to wheel also gives codi sudo permissions. 

Next I installed ssh and an additional shell, fish, with 'sudo pacman -S openssh'and 'sudo pacman -S fish' respectively. I switched shells with 'chsh -s fish' and was able to verify that shell worked too. Since fish already has a lot of its own built in color coding, I left it alone and switched back to bash for color coding. To start, I uncommented the color line in /etc/pacman.conf to add color coding to pacman installations. Then I editted ~/.bashrc changing PSI to '\[\e[0;92m\]\u@\h\[\033[00m\] \W\[\033[00m\]]\$ ' to make the username and hostname appear in bright green and the current directory in bright blue and then turning it back to default. I had a bit of trouble getting the brackets in the right place and turned evertyhing green for a while but this seems to be working now. Then I edited the same file to add some aliases. I added "alias c='clear'" to clear the screen, "alias ..='cd ..'" to go one level up in the file system, "alias ...='cd .. && cd ..' to go up two levels in the file system, "alias ....='cd .. && cd .. && cd ..'" to go up three levels in the file system, and my favorite, "alias oops='sudo $(history -p !!)' which is an alternative to sudo !!. 